section \<open>Abstract model of CHERI ISAs\<close>

subsection \<open>Capability abstraction\<close>

text \<open>Generated by Lem from \<open>capabilities.lem\<close>.\<close>

theory "Capabilities" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_values"
  "Sail.Sail2_prompt_monad"

begin 

\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>

record perms =
  
 permit_ccall ::" bool " 

     permit_execute ::" bool " 

     permit_load ::" bool " 

     permit_load_capability ::" bool " 

     permit_seal ::" bool " 

     permit_store ::" bool " 

     permit_store_capability ::" bool " 

     permit_store_local_capability ::" bool " 

     permit_system_access ::" bool " 

     permit_unseal ::" bool " 


record 'c Capability_class=

  is_tagged_method ::" 'c \<Rightarrow> bool " 

  is_sealed_method ::" 'c \<Rightarrow> bool " 

  get_mem_region_method ::" 'c \<Rightarrow> nat set " 

  get_obj_type_method ::" 'c \<Rightarrow> nat " 

  get_perms_method ::" 'c \<Rightarrow> perms " 

  get_cursor_method ::" 'c \<Rightarrow> nat " 

  get_global_method ::" 'c \<Rightarrow> bool " 

  set_tag_method ::" 'c \<Rightarrow> bool \<Rightarrow> 'c " 

  set_seal_method ::" 'c \<Rightarrow> bool \<Rightarrow> 'c " 

  set_obj_type_method ::" 'c \<Rightarrow> nat \<Rightarrow> 'c " 

  set_perms_method ::" 'c \<Rightarrow> perms \<Rightarrow> 'c " 

  set_global_method ::" 'c \<Rightarrow> bool \<Rightarrow> 'c " 

  cap_of_mem_bytes_method ::" memory_byte list \<Rightarrow> bitU \<Rightarrow>  'c option "



\<comment> \<open>\<open>val seal : forall 'cap. Capability 'cap => 'cap -> nat -> 'cap\<close>\<close>
definition seal  :: " 'cap Capability_class \<Rightarrow> 'cap \<Rightarrow> nat \<Rightarrow> 'cap "  where 
     " seal dict_Capabilities_Capability_cap c obj_type = (
  (set_seal_method   dict_Capabilities_Capability_cap) ((set_obj_type_method   dict_Capabilities_Capability_cap) c obj_type) True )" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  c  :: " 'cap " 
  and  obj_type  :: " nat "


\<comment> \<open>\<open>val unseal : forall 'cap. Capability 'cap => 'cap -> bool -> 'cap\<close>\<close>
definition unseal  :: " 'cap Capability_class \<Rightarrow> 'cap \<Rightarrow> bool \<Rightarrow> 'cap "  where 
     " unseal dict_Capabilities_Capability_cap c global1 = (
  (set_seal_method   dict_Capabilities_Capability_cap) ((set_obj_type_method   dict_Capabilities_Capability_cap) ((set_global_method   dict_Capabilities_Capability_cap) c (global1 \<and> (get_global_method   dict_Capabilities_Capability_cap) c))(( 0 :: nat))) False )" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  c  :: " 'cap " 
  and  global1  :: " bool "


\<comment> \<open>\<open>val leq_perms : perms -> perms -> bool\<close>\<close>
definition leq_perms  :: " perms \<Rightarrow> perms \<Rightarrow> bool "  where 
     " leq_perms p1 p2 = (
  ((permit_ccall   p1) \<longrightarrow>(permit_ccall   p2)) \<and>
  (((permit_execute   p1) \<longrightarrow>(permit_execute   p2)) \<and>
  (((permit_load   p1) \<longrightarrow>(permit_load   p2)) \<and>
  (((permit_load_capability   p1) \<longrightarrow>(permit_load_capability   p2)) \<and>
  (((permit_store   p1) \<longrightarrow>(permit_store   p2)) \<and>
  (((permit_store_capability   p1) \<longrightarrow>(permit_store_capability   p2)) \<and>
  (((permit_store_local_capability   p1) \<longrightarrow>(permit_store_local_capability   p2)) \<and>
  (((permit_system_access   p1) \<longrightarrow>(permit_system_access   p2)) \<and>
  ((permit_unseal   p1) \<longrightarrow>(permit_unseal   p2))))))))))" 
  for  p1  :: " perms " 
  and  p2  :: " perms "


\<comment> \<open>\<open>val leq_cap : forall 'cap. Capability 'cap, Eq 'cap => 'cap -> 'cap -> bool\<close>\<close>
definition leq_cap  :: " 'cap Capability_class \<Rightarrow> 'cap \<Rightarrow> 'cap \<Rightarrow> bool "  where 
     " leq_cap dict_Capabilities_Capability_cap c1 c2 = (
  (c1 = c2) \<or>
  ((\<not> ((is_tagged_method   dict_Capabilities_Capability_cap) c1)) \<or>
    (((is_tagged_method   dict_Capabilities_Capability_cap) c2) \<and>
     ((\<not> ((is_sealed_method   dict_Capabilities_Capability_cap) c1) \<and> \<not> ((is_sealed_method   dict_Capabilities_Capability_cap) c2)) \<and>
     ((((get_mem_region_method   dict_Capabilities_Capability_cap) c1) \<subseteq> ((get_mem_region_method   dict_Capabilities_Capability_cap) c2)) \<and>
     (((get_global_method   dict_Capabilities_Capability_cap) c1 \<longrightarrow> 
  (get_global_method   dict_Capabilities_Capability_cap) c2) \<and>
     (leq_perms ((get_perms_method   dict_Capabilities_Capability_cap) c1) ((get_perms_method   dict_Capabilities_Capability_cap) c2))))))))" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  c1  :: " 'cap " 
  and  c2  :: " 'cap "


\<comment> \<open>\<open>val invokable : forall 'cap. Capability 'cap => 'cap -> 'cap -> bool\<close>\<close>
definition invokable  :: " 'cap Capability_class \<Rightarrow> 'cap \<Rightarrow> 'cap \<Rightarrow> bool "  where 
     " invokable dict_Capabilities_Capability_cap cc cd1 = (
  (let pc = ((get_perms_method   dict_Capabilities_Capability_cap) cc) in
  (let pd = ((get_perms_method   dict_Capabilities_Capability_cap) cd1) in (is_tagged_method   dict_Capabilities_Capability_cap) cc \<and> ((is_tagged_method   dict_Capabilities_Capability_cap) cd1 \<and>
  ((is_sealed_method   dict_Capabilities_Capability_cap) cc \<and> ((is_sealed_method   dict_Capabilities_Capability_cap) cd1 \<and>
  ((permit_ccall   pc) \<and> ((permit_ccall   pd) \<and>
  (((get_obj_type_method   dict_Capabilities_Capability_cap) cc =(get_obj_type_method   dict_Capabilities_Capability_cap) cd1) \<and>
  ((permit_execute   pc) \<and> ((
  (get_cursor_method   dict_Capabilities_Capability_cap) cc \<in> (get_mem_region_method   dict_Capabilities_Capability_cap) cc) \<and>
  \<not>(permit_execute   pd))))))))))))" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  cc  :: " 'cap " 
  and  cd1  :: " 'cap "


\<comment> \<open>\<open> Derivation of capabilities, bounded by derivation depth to guarantee termination \<close>\<close>
\<comment> \<open>\<open>val cap_derivable_bounded : forall 'cap. Capability 'cap, SetType 'cap, Eq 'cap => nat -> set 'cap -> 'cap -> bool\<close>\<close>
fun  cap_derivable_bounded  :: " 'cap Capability_class \<Rightarrow> nat \<Rightarrow> 'cap set \<Rightarrow> 'cap \<Rightarrow> bool "  where 
     " cap_derivable_bounded dict_Capabilities_Capability_cap 0 C c = ( (c \<in> C))" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  C  :: " 'cap set " 
  and  c  :: " 'cap "
|" cap_derivable_bounded dict_Capabilities_Capability_cap ((Suc n)) C c = (
     ((\<exists> c'.  cap_derivable_bounded 
  dict_Capabilities_Capability_cap n C c' \<and> leq_cap 
  dict_Capabilities_Capability_cap c c')) \<or>
     ((\<exists> c'. \<exists> c''. 
        cap_derivable_bounded 
  dict_Capabilities_Capability_cap n C c' \<and>
        (cap_derivable_bounded 
  dict_Capabilities_Capability_cap n C c'' \<and>
        ((is_tagged_method   dict_Capabilities_Capability_cap) c' \<and> ((is_tagged_method   dict_Capabilities_Capability_cap) c'' \<and> (\<not> (
  (is_sealed_method   dict_Capabilities_Capability_cap) c'') \<and>
        (((is_sealed_method   dict_Capabilities_Capability_cap) c' \<and> ((permit_unseal  (
  (get_perms_method   dict_Capabilities_Capability_cap) c'')) \<and> (((get_obj_type_method   dict_Capabilities_Capability_cap) c' =(get_cursor_method   dict_Capabilities_Capability_cap) c'') \<and> (unseal dict_Capabilities_Capability_cap c' ((get_global_method   dict_Capabilities_Capability_cap) c'') = c)))) \<or>
         (\<not> ((is_sealed_method   dict_Capabilities_Capability_cap) c') \<and> ((permit_seal  (
  (get_perms_method   dict_Capabilities_Capability_cap) c'')) \<and> (seal dict_Capabilities_Capability_cap c' ((get_cursor_method   dict_Capabilities_Capability_cap) c'') = c)))))))))))" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  n  :: " nat " 
  and  C  :: " 'cap set " 
  and  c  :: " 'cap "


\<comment> \<open>\<open> TODO: Prove an upper bound for the derivation depth.  For a finite set of n
   capabilities, it seems a derivation depth of n+1 should be enough: If all
   but one capabilities in C are sealed, up to n-1 unsealing operations and
   possibly a restriction and a sealing operation might be necessary to derive
   the desired capability. \<close>\<close>
definition cap_derivable  :: " 'a Capability_class \<Rightarrow> 'a set \<Rightarrow> 'a \<Rightarrow> bool "  where 
     " cap_derivable dict_Capabilities_Capability_a C c = ( ((\<exists> n.  cap_derivable_bounded 
  dict_Capabilities_Capability_a n C c)))" 
  for  dict_Capabilities_Capability_a  :: " 'a Capability_class " 
  and  C  :: " 'a set " 
  and  c  :: " 'a "


\<comment> \<open>\<open>val reads_from_reg : forall 'regval. event 'regval -> maybe register_name\<close>\<close>
fun reads_from_reg  :: " 'regval event \<Rightarrow>(string)option "  where 
     " reads_from_reg (E_read_reg r _) = ( Some r )" 
  for  r  :: " string "
|" reads_from_reg _ = ( None )"


\<comment> \<open>\<open>val reads_reg_caps : forall 'regval 'cap. Capability 'cap, SetType 'cap =>
  ('regval -> set 'cap) -> event 'regval -> set 'cap\<close>\<close>
fun reads_reg_caps  :: " 'cap Capability_class \<Rightarrow>('regval \<Rightarrow> 'cap set)\<Rightarrow> 'regval event \<Rightarrow> 'cap set "  where 
     " reads_reg_caps dict_Capabilities_Capability_cap caps_of_regval1 (E_read_reg _ v) = ( set_filter 
  (is_tagged_method   dict_Capabilities_Capability_cap) (caps_of_regval1 v))" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  caps_of_regval1  :: " 'regval \<Rightarrow> 'cap set " 
  and  v  :: " 'regval "
|" reads_reg_caps dict_Capabilities_Capability_cap caps_of_regval1 _ = ( {} )" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  caps_of_regval1  :: " 'regval \<Rightarrow> 'cap set "


\<comment> \<open>\<open>val writes_to_reg : forall 'regval. event 'regval -> maybe register_name\<close>\<close>
fun writes_to_reg  :: " 'regval event \<Rightarrow>(string)option "  where 
     " writes_to_reg (E_write_reg r _) = ( Some r )" 
  for  r  :: " string "
|" writes_to_reg _ = ( None )"


\<comment> \<open>\<open>val writes_reg_caps : forall 'regval 'cap. Capability 'cap, SetType 'cap =>
  ('regval -> set 'cap) -> event 'regval -> set 'cap\<close>\<close>
fun writes_reg_caps  :: " 'cap Capability_class \<Rightarrow>('regval \<Rightarrow> 'cap set)\<Rightarrow> 'regval event \<Rightarrow> 'cap set "  where 
     " writes_reg_caps dict_Capabilities_Capability_cap caps_of_regval1 (E_write_reg _ v) = ( set_filter 
  (is_tagged_method   dict_Capabilities_Capability_cap) (caps_of_regval1 v))" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  caps_of_regval1  :: " 'regval \<Rightarrow> 'cap set " 
  and  v  :: " 'regval "
|" writes_reg_caps dict_Capabilities_Capability_cap caps_of_regval1 _ = ( {} )" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  caps_of_regval1  :: " 'regval \<Rightarrow> 'cap set "


\<comment> \<open>\<open>val reads_mem_val : forall 'regval. event 'regval -> maybe (nat * nat * list memory_byte * bitU)\<close>\<close>
fun reads_mem_val  :: " 'regval event \<Rightarrow>(nat*nat*(memory_byte)list*bitU)option "  where 
     " reads_mem_val (E_read_memt _ addr sz (v, t)) = ( Some (addr, sz, v, t))" 
  for  addr  :: " nat " 
  and  sz  :: " nat " 
  and  t  :: " bitU " 
  and  v  :: "(memory_byte)list "
|" reads_mem_val (E_read_mem _ addr sz v) = ( Some (addr, sz, v, B0))" 
  for  addr  :: " nat " 
  and  sz  :: " nat " 
  and  v  :: "(memory_byte)list "
|" reads_mem_val _ = ( None )"


\<comment> \<open>\<open>val reads_mem_cap : forall 'regval 'cap. Capability 'cap =>
  event 'regval -> maybe (nat * nat * 'cap)\<close>\<close>
definition reads_mem_cap  :: " 'cap Capability_class \<Rightarrow> 'regval event \<Rightarrow>(nat*nat*'cap)option "  where 
     " reads_mem_cap dict_Capabilities_Capability_cap e = (
  Option.bind (reads_mem_val e) ( \<lambda>x .  
  (case  x of
      (addr, sz, v, t) =>
  Option.bind
    ((cap_of_mem_bytes_method   dict_Capabilities_Capability_cap) v t)
    (\<lambda> c . 
     if(is_tagged_method   dict_Capabilities_Capability_cap) c then
       Some (addr, sz, c) else None)
  )))" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  e  :: " 'regval event "


\<comment> \<open>\<open>val writes_mem_val : forall 'regval. event 'regval -> maybe (nat * nat * list memory_byte * bitU)\<close>\<close>
fun writes_mem_val  :: " 'regval event \<Rightarrow>(nat*nat*(memory_byte)list*bitU)option "  where 
     " writes_mem_val (E_write_memt _ addr sz v t _) = ( Some (addr, sz, v, t))" 
  for  addr  :: " nat " 
  and  sz  :: " nat " 
  and  t  :: " bitU " 
  and  v  :: "(memory_byte)list "
|" writes_mem_val (E_write_mem _ addr sz v _) = ( Some (addr, sz, v, B0))" 
  for  addr  :: " nat " 
  and  sz  :: " nat " 
  and  v  :: "(memory_byte)list "
|" writes_mem_val _ = ( None )"


\<comment> \<open>\<open>val writes_mem_cap : forall 'regval 'cap. Capability 'cap =>
  event 'regval -> maybe (nat * nat * 'cap)\<close>\<close>
definition writes_mem_cap  :: " 'cap Capability_class \<Rightarrow> 'regval event \<Rightarrow>(nat*nat*'cap)option "  where 
     " writes_mem_cap dict_Capabilities_Capability_cap e = (
  Option.bind (writes_mem_val e) ( \<lambda>x .  
  (case  x of
      (addr, sz, v, t) =>
  Option.bind
    ((cap_of_mem_bytes_method   dict_Capabilities_Capability_cap) v t)
    (\<lambda> c . 
     if(is_tagged_method   dict_Capabilities_Capability_cap) c then
       Some (addr, sz, c) else None)
  )))" 
  for  dict_Capabilities_Capability_cap  :: " 'cap Capability_class " 
  and  e  :: " 'regval event "

end
